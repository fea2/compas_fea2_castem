import os

"""
This script reads results from .out files generated by a finite element analysis and converts them into an SQLite database.
It supports various types of field outputs such as displacements, reaction forces, reaction moments, stresses, and section forces.
The script creates tables in the SQLite database to store these results and their descriptions.
"""


def read_results_file(connection, field_output):
    """
    Read the .out results file and convert it to a dictionary.

    Parameters
    ----------
    database_path : path
        Path to the folder where the sqlite database will be created
    database_name : str
        Name of the database
    field_output : :class:`compas_fea2.problem.FieldOutput`
        FieldOutput object containing the nodes and/or element outputs to extract.
    """
    model = field_output.model
    step = field_output.step
    field_name = field_output.field_name
    problem_path = field_output.problem.path
    # Cast3m do not automatically store the tag of the node.
    # The dictionnary allnode gives the FEA2 tag corresponding to
    # the CASTEM node
    allnodes = {}
    with open(os.path.join(problem_path, "allnode.csv"), "r") as f:
        lines = f.readlines()
        for i in range(1, len(lines)):
            columns = lines[i].split()
            allnodes[columns[1]] = int(columns[0])  # allnode[noeu]=tag

    model = field_output.model
    step = field_output.step
    field_name = field_output.field_name
    problem_path = field_output.problem.path

    results = []
    with open(os.path.join(problem_path, f"{field_name}.inp"), "r") as f:
        lines = f.readlines()

        # all the data are stored in the doc
        full_data = []
        for line in lines:
            line_split = line.split()
            full_data.append(line_split)

        # the .inp file gives informations about the points composing the field
        # then about the results of the field. Only the results are extracted.
        nb_point = int(full_data[0][0])
        nb_comp = int(full_data[nb_point + 1][0])
        results_data = full_data[nb_point + 1 + nb_comp + 1 :]
        for i in range(nb_point):
            noeudi = results_data[i][0]
            input_keyi = allnodes.get(noeudi)
            member = getattr(model, field_output.results_func)(input_keyi)[0]
            values = results_data[i][1:]

            if not values:
                continue

            # # NOTE: OpenSees outputs the stresses at the integration points, so we need to average them to get the element stresses
            # if field_name == "s2d":
            #     num_integration_points = 4
            #     num_columns = len(values) // num_integration_points
            #     reshaped_data = np.array(values).reshape((num_integration_points, num_columns))
            #     averages = np.mean(reshaped_data, axis=0)
            #     values = averages.tolist()
            #     # NOTE: The OpenSees output is generalised stress, so we need to convert it to True stress
            #     t = member.section.t
            #     true_stresses = {
            #         "sigma_11": values[0] / t,
            #         "sigma_22": values[1] / t,
            #         "tau_12": values[2] / t,
            #         "sigma_b11": 6 * values[3] / t**2,
            #         "sigma_b22": 6 * values[4] / t**2,
            #         "sigma_b12": 6 * values[5] / t**2,
            #         "tau_q1": values[6] / (t * 5 / 6),  # Assuming shear area = 5/6 * t
            #         "tau_q2": values[7] / (t * 5 / 6),
            #     }
            #     values = list(true_stresses.values())

            if len(values) < len(field_output.components_names):
                values = values + [0.0] * (len(field_output.components_names) - len(values))
            elif len(values) > len(field_output.components_names):
                values = values[: len(field_output.components_names)]
            else:
                values = values

            results.append([member.key] + [step.name, member.part.name] + values)

    field_output.create_sql_table(results)


def process_modal_shapes(connection, step):
    problem_path = step.problem.path
    model = step.model

    eigenvalues = []
    with open(os.path.join(problem_path, "eigenvalues.out"), "r") as f:
        lines = f.readlines()
        for line in lines:
            eigenvalues.append(line.split())

    eigenvectors = []
    with open(os.path.join(problem_path, "eigenvectors.out"), "r") as f:
        lines = f.readlines()
        for line in lines:
            eigenvectors.append(line.split())

    cursor = connection.cursor()

    # Create table for eigenvalues
    cursor.execute(
        """
    CREATE TABLE IF NOT EXISTS eigenvalues (
        id INTEGER PRIMARY KEY,
        step TEXT,
        mode INTEGER,
        lambda REAL,
        omega REAL,
        freq REAL,
        period REAL
        )
    """
    )

    # Insert eigenvalues into the database
    for eigenvalue in eigenvalues:
        cursor.execute(
            """
        INSERT INTO eigenvalues (step, mode, lambda, omega, freq, period)
        VALUES (?, ?, ?, ?, ?, ?)
        """,
            [step.name] + eigenvalue,
        )
    connection.commit()

    for i, eigenvector in enumerate(eigenvectors):
        if len(eigenvector) < 8:
            eigenvector = eigenvector + [0.0] * (8 - len(eigenvector))
        node = model.find_node_by_inputkey(int(eigenvector[1]))[0]
        eigenvectors[i] = [
            eigenvector[0],
            step.name,
            node.part.name,
            node.input_key,
        ] + eigenvector[2:]

    # Create table for modal shapes
    cursor.execute(
        f"""
    CREATE TABLE IF NOT EXISTS eigenvectors (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        mode INTEGER,
        step TEXT,
        part TEXT,
        key INTEGER,
        {",\n".join([f"{c} REAL" for c in ["x", "y", "z", "xx", "yy", "zz"]])}
        )
    """
    )
    # Insert modal shape data into the database
    for eigenvector in eigenvectors:
        cursor.execute(
            f"""
        INSERT INTO eigenvectors (mode, step, part, key, {", ".join([c for c in ["x", "y", "z", "xx", "yy", "zz"]])})
        VALUES (?, ?, ?, ?, ?, ? ,?, ?, ?, ?)
        """,
            eigenvector,
        )

    connection.commit()

    print(f"Modal shapes and eigenvalues successfully saved to {problem_path}")
